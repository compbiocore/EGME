---
title: "trna_plots"
format: html
editor: visual
---

# Overview

This notebook generates tRNA coverage plots. The file inputs are all on:

`smb://files22.brown.edu/research/BM_SpadeLab/EGME/CBC/CBC_Yuan_updates/sRNAtoolbox/sRNAbench_results/`

and organized as separate zipped folders under `Library_xx.fastq.zip` , e.g. `Library_01.fastq.zip`. We have copied them `/Users/aguang/CORE/egme/research_mount` for ability to use in R. (tried a permanent local mount from cifs but couldn't figure out syntax) The relevant files in each folder are the `reads.annotation` files, which have the following column structures (taken from the sRNAbench toolkit manual):

1.  read sequence
2.  the read count 
3.  RPM: The Reads Per Million normalized by the total number of genome mapped reads (genome mode) or the total number of reads in the analysis (sequence library mode)
4.  Classification group. It consists of the name of annotation file (for libs=) or hairpin/mature (microRNAs from miRBase) plus the mapping orientation (sense or anti-sense). The format is “AnnotationGroup#Orientation”. Note that the name can be “mixed” if the read maps to several different annotations. 
5.  Mapped Annotations: This column contains all annotations to which the read maps. The format for the mapping to one element is: “AnnotationGroup#AnnotationName#Orientation#Chromosome position”. Note that the chromosome position is only applicable in the genome mode (for Library mode a dummy value is set ’s’). As a read can map to several different annotations, those are separated by ’\$’. For example, “hv_030312_v2_18#MLOC_55934.3#antisense#s\$hv_030312_v2_18#MLOC_55933.2#sense#s” means that i) the corresponding read mapped to twice (two annotation strings separated by one dollar sign), ii) the read maps one gene in sense and another one in antisense direction, iii) “hv_030312_v2_18 is the name of the library (AnnotationGroup) given at the common line like this libs=, iv) The gene names (AnnotationName) are MLOC_55933.2 and MLOC_55934.3 
6.  the number of mapped annotation

For example:

```         
TAGGATTGGGTGTATTGGTAGCACGGAGAATTTTGAATTCTTAGG 2 0.1997018650856137 Rnor_6_0_RNAcentral#sense Rnor_6_0_RNAcentral#URS00001EA296_10116:tRNA:Rattus_norvegicus#sense#URS00001EA296_10116:tRNA:Rattus_norvegicus,1,45$Rnor_6_0_RNAcentral#URS00004876BF_10116:tRNA:Rattus_norvegicus#sense#URS00004876BF_10116:tRNA:Rattus_norvegicus,1,45 2
```

or

```         
CCGCGGCCCGGGTTCGTTTCCC 3 0.2995527976284205 Rnor_6_0_genomic_tRNA#sense Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr13_random.trna25-GluCTC:tRNA#sense#Rattus_norvegicus_chr13_random.trna25-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr13.trna3809-GluCTC:tRNA#sense#Rattus_norvegicus_chr13.trna3809-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr2.trna4121-GluTTC:tRNA#sense#Rattus_norvegicus_chr2.trna4121-GluTTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr10.trna11370-GluCTC:tRNA#sense#Rattus_norvegicus_chr10.trna11370-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr2.trna4117-GluTTC:tRNA#sense#Rattus_norvegicus_chr2.trna4117-GluTTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr13_random.trna22-GluCTC:tRNA#sense#Rattus_norvegicus_chr13_random.trna22-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr1.trna16347-GluCTC:tRNA#sense#Rattus_norvegicus_chr1.trna16347-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr2.trna7260-GluCTC:tRNA#sense#Rattus_norvegicus_chr2.trna7260-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr13.trna2187-GluCTC:tRNA#sense#Rattus_norvegicus_chr13.trna2187-GluCTC:tRNA,41,62$Rnor_6_0_genomic_tRNA#Rattus_norvegicus_chr17.trna1684-GluCTC:tRNA#sense#Rattus_norvegicus_chr17.trna1684-GluCTC:tRNA,41,62 10
```

```{r setup, include=FALSE}
#install.packages(c("tidyverse", "zip", "fs"))
library(tidyverse)
library(zip)
library(fs)
# Define the base directory path and the list of tRNAs
base_path <- "/Users/aguang/CORE/egme/research_mount/"
tRNA_list <- c("GluCTC", "AlaAGC", "CysGCA", "GluTTC", "LysCTT", "GlyCCC")
```

We write a function `process_tRNA_data` that given a file path and list of tRNAs:

-   reads the annotation files in the files

-   creates a tsv from the annotation files

-   creates

```{r process_function, include=FALSE}
# Function to process a single annotation file
process_tRNA_data <- function(file_path, tRNA_list) {
  temp_dir <- tempdir()
  unzip_path <- file.path(temp_dir, basename(file_path))
  
  # Unzip the file
  zip::unzip(file_path, exdir = unzip_path)
  
  # Read the annotation file
  annotation_file <- file.path(unzip_path, list.files(unzip_path, pattern = "reads.annotation", recursive = TRUE))
  
  # Read the data, handling potential issues with extra columns
  df <- read_tsv(annotation_file, 
                 col_names = c("sequence", "read_count", "RPM", "classification", "mapped_annotations", "num_mapped"),
                 show_col_types = FALSE) %>%
    mutate(mapped_annotations = as.character(mapped_annotations)) # Ensure column is character
  
  # Initialize a list to store tRNA_dfs for each tRNA
  tRNA_dfs <- list()
  
  # Loop through each tRNA of interest
  for (tRNA in tRNA_list) {
    # Filter for the specific tRNA and process the mapped_annotations column
    tRNA_df <- df %>%
      filter(str_detect(mapped_annotations, tRNA)) %>%
      rowwise() %>%
      mutate(
        # Extract the first matching annotation for position extraction
        first_mapping = str_extract(mapped_annotations, paste0("Rattus_norvegicus_chr.*", tRNA, ":tRNA,[^$]+")),
        # Extract start and end positions
        positions = str_extract(first_mapping, "[0-9]+,[0-9]+"),
        start = as.integer(str_extract(positions, "[0-9]+")),
        end = as.integer(str_extract(str_remove(positions, "[0-9]+,"), "[0-9]+"))
      ) %>%
      ungroup() %>%
      filter(!is.na(start)) # Remove rows where positions couldn't be extracted
    
    tRNA_dfs[[tRNA]] <- tRNA_df
  }
  
  individual_tRNA_sequences <- bind_rows(tRNA_dfs, .id = "tRNA_name")
  fs::dir_delete(temp_dir)
  return(individual_tRNA_sequences)
}
    
    # Generate a tidy data frame of coverage counts
    #tRNA_coverage <- tRNA_df %>%
    #  rowwise() %>%
    #  mutate(position = list(seq(start, end))) %>%
    #  unnest(position) %>%
    #  group_by(position) %>%
    #  dplyr::summarise(coverage = sum(read_count), .groups = 'drop')
    
    #coverage_data[[tRNA]] <- tRNA_coverage
    #}
  

  
  #return(coverage_data)
#}
```

```{r coverage, eval=FALSE}
# Create a list of all file paths
file_paths <- sprintf("%sLibrary_%02d.fastq.zip", base_path, 1:29)

# Initialize a list to store aggregated sequence data for all tRNAs
all_tRNA_sequences <- list()

# Loop through all files and process them
for (i in seq_along(file_paths)) {
  file <- file_paths[i]
  cat("Processing file:", file, "\n")
  
  current_sequences <- process_tRNA_data(file, tRNA_list)
  
  if (nrow(current_sequences)>0) {
      all_tRNA_sequences[[i]] <- current_sequences
  }
}
  
# combine all files
combined_sequences <- bind_rows(all_tRNA_sequences, .id="id")

# assign dosage based on id
matchdf <- data.frame(id=1:40,dosage=rep(c(0,0,50,50,60,60,75,75),5))
combined_sequences$dosage <- matchdf$dosage[match(combined_sequences$id, matchdf$id)]

  
# Create a sequence ID for each unique sequence based on length and position
plot_data <- combined_sequences %>%
  arrange(tRNA_name, start, desc(end)) %>%
  group_by(tRNA_name) %>%
  mutate(sequence_id = row_number()) %>%
  ungroup() %>%
    select(tRNA_name, start, end, sequence_id, read_count) %>%
    group_by(tRNA_name, start, end) %>%
    dplyr::summarise(read_count=sum(read_count)) %>%
    group_by(tRNA_name) %>%
    arrange(tRNA_name, start, desc(end)) %>%
    mutate(ymax=cumsum(read_count),ymin=lag(ymax,n=1,default=0), sequence_id=row_number())

# Calculate the coverage for the black line plot
coverage_line_data <- plot_data %>%
  rowwise() %>%
  mutate(position = list(seq(start, end))) %>%
  unnest(position) %>%
  group_by(tRNA_name, position) %>%
  summarise(total_coverage = sum(read_count), .groups = 'drop')

write_csv(plot_data, file=file.path("/Users/aguang/CORE/egme/EGME/notebooks/plot_data.csv"))
write_csv(coverage_line_data, file=file.path("/Users/aguang/CORE/egme/EGME/notebooks/coverage_line_data.csv"))

# Aggregate the final coverage by position and tRNA
#final_coverage_data <- bind_rows(all_tRNA_coverage, .id = "tRNA_name") %>%
#  group_by(tRNA_name, position) %>%
#  summarise(total_coverage = sum(coverage), .groups = 'drop')
#write_csv(final_coverage_data,file=file.path("/Users/aguang/CORE/egme/EGME/notebooks/final_coverage_data.csv"))
```

```{r, echo=FALSE}
# Create the coverage only ggplot2 figure
coverage_line_data$tRNA_name <- factor(coverage_line_data$tRNA_name, c("GlyCCC","GluTTC","GluCTC","LysCTT","AlaAGC","CysGCA"))
ggplot(coverage_line_data, aes(x = position, y = total_coverage, fill = tRNA_name)) +
  geom_bar(stat = "identity") +
  facet_wrap(~tRNA_name, scales = "free") +
  labs(
    title = "tRNA Coverage Plots Across All Libraries",
    x = "Position on tRNA",
    y = "Total Read Coverage Count"
  ) +
  theme_minimal() +
  theme(
    legend.position = "none",
    plot.title = element_text(hjust = 0.5, face = "bold"),
    strip.text = element_text(face = "bold")
  )
```

```{r overlay, echo=FALSE}
# Create the ggplot2 overlay figure
coverage_line_data$tRNA_name <- factor(coverage_line_data$tRNA_name, c("GlyCCC","GluTTC","GluCTC","LysCTT","AlaAGC","CysGCA"))

ggplot(coverage_line_data, aes(x = position, y = total_coverage, color = tRNA_name)) +
  geom_path(stat = "identity", position="identity") +
  labs(
    title = "tRNA Coverage Plots Across All Libraries",
    x = "Position on tRNA",
    y = "Total Read Coverage Count"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    strip.text = element_text(face = "bold")
  )
```

```{r msa_coverage}
# Create the ggplot2 figure
ggplot() +
  # Layer 1: The stacked heatmap
  geom_rect(
    data = plot_data,
    aes(
      xmin = start,
      xmax = end,
      ymin = ymin,
      ymax = ymax, 
      #ymin = sequence_id - 0.5,
      #ymax = sequence_id + 0.5,
      fill = read_count
    ),
    alpha = 0.8
  ) +
  # Layer 2: The coverage line plot
  geom_line(
    data = coverage_line_data,
    aes(x = position, y = total_coverage, color=tRNA_name),
    size = 1,
    color = "black"
  ) +
  # Customization and labels
  facet_wrap(~tRNA_name, scales = "free") +
  scale_fill_gradient(name = "Read Count") +
  labs(
    title = "tRNA Sequence Coverage Across All Libraries",
    x = "Position",
    y = "Sequences"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    strip.text = element_text(face = "bold")
  )
```

```{r}
ggplot() +
  # Layer 1: The stacked heatmap
  geom_rect(
    data = plot_data,
    aes(
      xmin = start,
      xmax = end,
      ymin = sequence_id - 0.5,
      ymax = sequence_id + 0.5,
      fill = read_count,
      
    ),
    alpha = 0.8
  ) +
  # Customization and labels
  facet_wrap(~tRNA_name, scales = "free") +
  scale_fill_viridis_c(name = "Read Count", option = "magma") +
  labs(
    title = "tRNA Sequence Coverage Across All Libraries",
    x = "Position",
    y = "Sequences"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(hjust = 0.5, face = "bold"),
    strip.text = element_text(face = "bold")
  )
```

```{r}
# Create a sequence ID for each unique sequence based on length and position
plot_data_dosage <- combined_sequences %>%
  arrange(tRNA_name, start, desc(end)) %>%
  group_by(tRNA_name, dosage) %>%
  mutate(sequence_id = row_number()) %>%
  ungroup() %>%
    select(tRNA_name, start, end, sequence_id, read_count, dosage) %>%
    group_by(tRNA_name, dosage, start, end) %>%
    dplyr::summarise(read_count=sum(read_count)) %>%
    group_by(tRNA_name, dosage) %>%
    arrange(tRNA_name, start, desc(end)) %>%
    mutate(ymax=cumsum(read_count),ymin=lag(ymax,n=1,default=0), sequence_id=row_number())
```
